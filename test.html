<!doctype html>
<html>
<head>
	<title>GLSL Test</title>
	<meta charset="utf-8"/>
	<meta name="viewport" content="width=device-width, initial-scale=1"/>
	<link href="test.css" rel="stylesheet" type="text/css"/>
	<!-- <script type="text/javascript" src="https://rawgit.com/patriciogonzalezvivo/glslCanvas/master/dist/GlslCanvas.js"></script> -->
	<script type="application/javascript" src="webgl-utils.js"></script>
	<script src="J3DI.js"> </script>

	<script type="x-shader/x-vertex" id="vertex-shader">
	attribute vec4 v_position;
	void main() {
		// gl_Position = vec4(0.0, 0.0, 0.0, 1.0);
		gl_Position = v_position;
		// gl_PointSize = 1200.0;
	}
	</script>

	<script type="x-shader/x-fragment" id="fragment-shader">
	// precision mediump float;
	// uniform float uv;
	// void main() {
	// 	// gl_FragColor = vec4(0.18, 0.54, 0.34, 1.0);
	// 	gl_FragColor = vec4(gl_FragCoord.x/1000.0, 0.0, 0.0, 1.0);
	// 	// gl_FragColor = vec4(gl_FragCoord.x/uv, 0.0, 0.0, 1.0);
	// }

	precision mediump float;

	uniform float u_time;
	// uniform vec2 u_resolution;
	// float u_time;
	vec2 u_resolution = vec2(1280.0, 720.0);

	float seed = 1.0;
	const int octaves = 8;
	float octaveFalloff = 0.4;
	float noiseFrequency = 0.443;
	float noiseLacunarity = 1.516;
	float mainFbmFrequency = 2.27;
	float mainWarpGain = 1.15;
	vec2 qFreq = vec2(12.0, 0.37);
	vec2 qAmp = vec2(0.0, 0.0);
	vec2 rFreq = vec2(0.0, 0.2);
	vec3 paletteBrightness = vec3(0.5, 0.5, 0.5);
	vec3 paletteContrast = vec3(0.5, 0.5, 0.4);
	vec3 paletteFrequency = vec3(1.0, 1.0, 1.0);
	vec3 palettePhase = vec3(0.28, 0.3, 0.3);
	float contrast = 1.27;
	float brightness = 0.0;


	// signed hash function (-1 to 1)
	float shash(vec2 p) {
		return -1.0 + 2.0*fract((1e4 + seed) * sin(17.0 * p.x + p.y * 0.1) *
									(0.1 + abs(sin(p.y * 13.0 + p.x))));
	}

	// 2D noise
	// https://www.shadertoy.com/view/4dS3Wd
	float noise(vec2 x) {
		vec2 i = floor(x);
		vec2 f = fract(x);

		// Four corners in 2D of a tile
		float a = shash(i);
		float b = shash(i + vec2(1.0, 0.0));
		float c = shash(i + vec2(0.0, 1.0));
		float d = shash(i + vec2(1.0, 1.0));

		vec2 u = f * f * (3.0 - 2.0 * f);
		return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
	}

	float fbm(vec2 x) {
		float v = 0.0;
		float a = 0.5;
		float maxAmp = a;
		float freq = noiseFrequency;
		float lac = noiseLacunarity;
		vec2 shift = vec2(100);
		// Rotate to reduce axial bias
		mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));

		// ridge
		for (int i = 0; i < octaves; i++) {
			v += a * abs(noise(x*freq));
			x = rot * x * 2.0 + shift;
			maxAmp += a*octaveFalloff;
			a *= octaveFalloff;
			freq *= noiseLacunarity;
		}
		v = 1.0 - v;
		v = pow(v, 5.0);
		// Normalize noise value so that maximum amplitude = 1.0
		v /= maxAmp;

		return v;
	}

	vec3 palette(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d)
	{
		return a + b * cos(6.28318 * (c * t + d));
	}

	// struct Result
	// 	{
	// 		float f;
	// 		vec2 q;
	// 		vec2 r;
	// 	} result;
	//
	// Result func(in vec2 uv)
	// {
	//     vec4 var = vec4(0.1,
	//                     0.03,
	//                     u_time * 0.00164,
	//                     u_time * -0.00251);
	//
	// 	Result result;
	//
	// 	vec2 q = vec2(fbm(qFreq.x*uv + vec2(var.x, var.y)),
	// 								fbm(qFreq.y*uv + vec2(1.5*(atan(u_time*0.09)), 0.61*sin(u_time*0.053))));
	//
	// 	vec2 r = vec2(fbm(rFreq.x*uv + qAmp.x*q + uv + vec2(var.z, var.w)),
	// 								fbm(rFreq.y*uv + qAmp.y*q + uv + vec2(u_time*0.0043, u_time*0.0123)));
	//
	// 	float mainFreq = mainFbmFrequency;
	// 	float warpGain = mainWarpGain;
	// 	float f = fbm(mainFreq*uv + warpGain*r);
	// 	result.f = f;
	// 	result.q = q;
	// 	result.r = r;
	// 	return result;
	// }

	void main()
	{
	    vec2 scroll = vec2(0.02*sin(u_time*0.0001), 0.1);
	    scroll *= 0.2;
	    float palettePhaseSpeed = mod((u_time * 0.04), 1.0);
	    // Normalized pixel coordinates (from 0 to 1)
	    // vec2 uv = fragCoord/iResolution.xy;
		vec2 uv = gl_FragCoord.xy / u_resolution.y;
	    uv *= 2.0;
	    uv += vec2(u_time)*scroll;

		// Result res = func(uv + scroll*u_time*0.1);
		// float f = fbm(uv);
		float f = uv.y;
	    //Result res = func(uv);
		// float f = res.f;
		// vec2 q = res.q;
		// vec2 r = res.r;
		vec3 color = vec3(0.0);

		vec3 a = paletteBrightness;
		vec3 b = paletteContrast;
		vec3 c = paletteFrequency;
		vec3 d = palettePhase.xyz;
		d = mod(d + palettePhaseSpeed, vec3(1.0));
		color = palette(f, a, b, c, d);

		gl_FragColor = vec4(color, 1.0);
	}

	</script>

	<script>
	var g = {};
	var u_time_location

	function init()
	{
		// Initialize
		var gl = initWebGL(
			// The id of the Canvas Element
			"example");
			if (!gl) {
				return;
			}
			var program = simpleSetup(
				gl,
				// The ids of the vertex and fragment shaders
				"vertex-shader", "fragment-shader",
				// The vertex attribute names used by the shaders.
				// The order they appear here corresponds to their index
				// used later.
				[],
				// The clear color and depth values
				[ 0, 0, 0.5, 1 ], 10000);

				// gl.uniform1f(gl.getUniformLocation(program, 'uv'), 0)
				// gl.uniform1f(gl.getUniformLocation(program, 'uv'), 1000.0)
				u_time_location = gl.getUniformLocation(program, 'u_time')

				gl.enableVertexAttribArray(0);
				var vertexPositionAttribute = gl.getAttribLocation(program, "v_position");
				var quad_vertex_buffer = gl.createBuffer();
				var quad_vertex_buffer_data = new Float32Array([
					-1.0, -1.0, 0.0,
					1.0, -1.0, 0.0,
					-1.0,  1.0, 0.0,
					-1.0,  1.0, 0.0,
					1.0, -1.0, 0.0,
					1.0,  1.0, 0.0]);
				gl.bindBuffer(gl.ARRAY_BUFFER, quad_vertex_buffer);
				gl.bufferData(gl.ARRAY_BUFFER, quad_vertex_buffer_data, gl.STATIC_DRAW);
				gl.vertexAttribPointer(vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);
				gl.enableVertexAttribArray(vertexPositionAttribute)
				// gl.drawArrays(gl.TRIANGLES, 0, 6);
				// buffer = gl.createBuffer();
				// gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
				// gl.vertexAttribPointer(0, 1, gl.FLOAT, false, 0, 0);

				return gl;
			}

			var requestId;

			function reshape(gl)
			{
				// change the size of the canvas's backing store to match the size it is displayed.
				var canvas = document.getElementById('example');
				if (canvas.clientWidth == canvas.width && canvas.clientHeight == canvas.height)
				return;

				canvas.width = canvas.clientWidth;
				canvas.height = canvas.clientHeight;

				// Set the viewport and projection matrix for the scene
				gl.viewport(0, 0, canvas.clientWidth, canvas.clientHeight);
			}

			function drawPicture(gl)
			{
				// Make sure the canvas is sized correctly.
				reshape(gl);

				// Clear the canvas
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

				currentTime += incTime
				gl.uniform1f(u_time_location, currentTime)

				// Draw the cube
				// gl.drawElements(gl.TRIANGLES, 2, gl.UNSIGNED_BYTE, 0);
				// gl.drawArrays(gl.POINTS, 0, 1);
				gl.drawArrays(gl.TRIANGLES, 0, 6);

				// Show the framerate
				framerate.snapshot();
			}

			function start()
			{
				var c = document.getElementById("example");

				c.addEventListener('webglcontextlost', handleContextLost, false);
				c.addEventListener('webglcontextrestored', handleContextRestored, false);

				var gl = init();
				if (!gl) {
					return;
				}

				currentTime = 0.0;
				incTime = 1.0 / 60.0;

				framerate = new Framerate("framerate");
				var f = function() {
					drawPicture(gl);
					requestId = window.requestAnimFrame(f, c);
				};
				f();

				function handleContextLost(e) {
					e.preventDefault();
					clearLoadingImages();
					if (requestId !== undefined) {
						window.cancelAnimFrame(requestId);
						requestId = undefined;
					}
				}

				function handleContextRestored() {
					init();
					f();
				}
			}
			</script>


		</head>
		<body onload="start()">
			<!-- <canvas class="glslCanvas" data-fragment-url="shader.glsl" width="1920" height="1080"</canvas> -->
			<canvas id="example">
				It no work :(
			</canvas>
			<div id="framerate"></div>
		</body>
		</html>
